{
  parserClass="io.teocloud.teointellijidea.parser.TeoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Teo"
  psiImplClassSuffix="Impl"
  psiPackage="io.teocloud.teointellijidea.psi"
  psiImplPackage="io.teocloud.teointellijidea.psi.impl"

  elementTypeHolderClass="io.teocloud.teointellijidea.psi.TeoTypes"
  elementTypeClass="io.teocloud.teointellijidea.psi.TeoElementType"
  tokenTypeClass="io.teocloud.teointellijidea.psi.TeoTokenType"
}

teoFile ::= item_*

private item_ ::= (import_statement|let_declaration|model_definition|enum_definition|config_block|comment|bad_doc_comment|NEWLINE|WHITESPACE)

ws_eol ::= (NEWLINE | WHITESPACE)+
new_line_with_leading_ws ::= NEWLINE WHITESPACE*

padded_comma ::= ws_eol? COMMA ws_eol?
padded_colon ::= ws_eol? COLON ws_eol?
padded_block_open ::= BLOCK_OPEN ws_eol?
padded_block_close ::= ws_eol? BLOCK_CLOSE
padded_brack_open ::= BRACK_OPEN ws_eol?
padded_brack_close ::= ws_eol? BRACK_CLOSE
padded_paren_open ::= PAREN_OPEN ws_eol?
padded_paren_close ::= ws_eol? PAREN_CLOSE

triple_line_comment_full_line ::= WHITESPACE* TRIPLE_LINE_COMMENT NEWLINE
doc_comment ::= triple_line_comment_full_line triple_line_comment_full_line* WHITESPACE*
bad_doc_comment ::= triple_line_comment_full_line triple_line_comment_full_line* WHITESPACE*
comment ::= DOUBLE_LINE_COMMENT

import_statement ::= IMPORT_KEYWORD ((ws_eol? import_identifier_list ws_eol?)|WHITESPACE+) STRING_LITERAL

import_identifier_list ::= padded_block_open (IDENTIFIER (COMMA IDENTIFIER)* COMMA?)? padded_block_close ws_eol? FROM_KEYWORD ws_eol?

let_declaration ::= doc_comment? LET_KEYWORD WHITESPACE+ IDENTIFIER WHITESPACE* EQUAL_SIGN WHITESPACE* expression

model_definition ::= doc_comment? item_decorator_list? MODEL_KEYWORD ws_eol model_name ws_eol? padded_block_open (block_decorator | field_definition | comment | ws_eol)* padded_block_close
item_decorator_list ::= item_decorator (ws_eol item_decorator)* ws_eol
model_name ::= IDENTIFIER

enum_name ::= IDENTIFIER
enum_definition ::= doc_comment? item_decorator_list? ENUM_KEYWORD ws_eol enum_name ws_eol? padded_block_open (block_decorator | enum_value_declaration | comment | ws_eol)* padded_block_close
enum_value_declaration ::= doc_comment? item_decorator_list? ws_eol? IDENTIFIER NEWLINE

item_decorator ::= AT identifier_unit

block_decorator ::= DOUBLE_AT identifier_unit

pipeline ::= DOLLAR_SIGN identifier_unit

CONFIG_KEYWORDS ::= CONFIG_KEYWORD | CONNECTOR_KEYWORD | CLIENT_KEYWORD | ENTITY_KEYWORD

config_block ::= CONFIG_KEYWORDS (WHITESPACE+ IDENTIFIER)? ws_eol+ padded_block_open (ws_eol? (config_item|comment) NEWLINE)* padded_block_close

config_item::= doc_comment? IDENTIFIER WHITESPACE+ expression

field_definition ::= doc_comment? item_decorator_list? IDENTIFIER WHITESPACE* COLON WHITESPACE* field_type

field_type ::= IDENTIFIER ITEM_OPTIONAL? (ARITY COLLECTION_OPTIONAL?)?

ARITY ::= (BLOCK_OPEN BLOCK_CLOSE)|(BRACK_OPEN BRACK_CLOSE)

ITEM_OPTIONAL ::= QUESTION
COLLECTION_OPTIONAL ::= QUESTION

nullish_coalescing ::= unit (ws_eol* DOUBLE_QUESTION ws_eol* unit)+

group ::= "(" expression ")"

expression ::= (nullish_coalescing | literal | IDENTIFIER | group | pipeline) (subscript | "." IDENTIFIER | argument_list)*

subscript ::= BRACK_OPEN ws_eol* expression ws_eol* BRACK_CLOSE

argument_list ::= PAREN_OPEN (argument | named_argument)* PAREN_CLOSE

argument ::= expression

named_argument ::= IDENTIFIER padded_colon expression

unit ::= (group | NULL_LITERAL | BOOL_LITERAL | NUMERIC_LITERAL | STRING_LITERAL | enum_choice_literal | tuple_literal | IDENTIFIER) (subscript | DOT IDENTIFIER | argument_list)*
identifier_unit ::= IDENTIFIER (subscript | DOT IDENTIFIER | argument_list)*
tuple_literal ::= padded_paren_open (padded_comma | (expression padded_comma (expression (padded_comma expression)* padded_comma?)*)) padded_paren_close
array_literal ::= padded_brack_open (expression (padded_comma expression)* padded_comma?)? padded_brack_close
named_expression ::= expression ws_eol* padded_colon ws_eol* expression
dictionary_literal ::= padded_block_open (named_expression (padded_comma named_expression)* padded_comma?)? padded_block_close

literal ::= STRING_LITERAL | NUMERIC_LITERAL | BOOL_LITERAL | array_literal | dictionary_literal | tuple_literal | RANGE_LITERAL | enum_choice_literal

enum_choice_literal ::= DOT IDENTIFIER
